(function(){

    require('dotenv').config();
    require( "console-stamp" )( console, { pattern : "dd/mm/yyyy HH:MM:ss.l" } );

    //db=mysql - один возможных вариантов
    var mysql      = require('mysql');
    var pool;

    var sha1 = require('sha1');

    var colors = require('colors/safe');

    var main = require('../../main');

    var validator = require('validator');

    exports.init = init;

    exports.getUserIdByToken = getUserIdByToken;

    exports.authPhone = authPhone;
    exports.authSms = authSms;
    exports.addAsset = addAsset;
    exports.getAssets = getAssets;
    exports.getAssetHistory = getAssetHistory;
    exports.renameAsset = renameAsset;
    exports.deleteAsset = deleteAsset;

    exports.transfer = transfer;
    exports.declineTransfer = declineTransfer;
    exports.acceptTransfer = acceptTransfer;

    exports.setProfile = setProfile;
    exports.getProfile = getProfile;

    exports.setPushToken = setPushToken;

    exports.setSaldo = setSaldo;
    exports.acceptNewSaldo = acceptNewSaldo;
    exports.declineNewSaldo = declineNewSaldo;

    exports.ionline = ionline;

    exports.transferFromTemporaryAsset2Asset = transferFromTemporaryAsset2Asset;
    exports.deleteFromTemporaryAsset = deleteFromTemporaryAsset;

    exports.updateGoods = updateGoods;

    exports.deleteTransactionsHistory = deleteTransactionsHistory;

    exports.deleteAccount = deleteAccount;

    var rabbit = require("amqplib").connect('amqp://'+process.env.RABBITMQ_LOGIN+":"+
        process.env.RABBITMQ_PASS+"@"+process.env.RABBITMQ_SEVER_IP);

    var rabbit2 = require("amqplib").connect('amqp://'+process.env.RABBITMQ_LOGIN+":"+
        process.env.RABBITMQ_PASS+"@"+process.env.RABBITMQ_SEVER_IP);

    var redis = require("redis");
    var redisClient;


    function init(cb) {

        pool  = mysql.createPool({
            connectionLimit : 2000,
            host     : process.env.DB_HOST,
            user     : process.env.DB_USER,
            password : process.env.DB_PASS,
            database : process.env.DB_DATABASE
        });
        console.log('db inited.');

        redisClient = redis.createClient({
            host: process.env.REDIS_HOST,
            port: process.env.REDIS_PORT,
            password: process.env.REDIS_PASS
        });

        redisClient.on('error', function (err) {
           console.log( colors.red("index.redis.on.error:", err) );
        });

        redisClient.on("connect", function () {
           console.log( colors.green("redis is connected") );
            console.log( colors.green("reading users data into RAM...") );
            redisCacheUpdate();
            console.log( colors.green("users data into RAM is updated.") );
        });


        if(cb)cb();
    }



    //регистрируем нового пользователя или авторизуем существующего

    function authPhone(jsonData) {

        var jData = {};
        jData.action = jsonData.action;
        jData.socketId = jsonData.socketId;
        jData.requestId = jsonData.requestId;

        console.log("authPhone", jData.requestId, jsonData.requestId);

        //валидация входящих переменных
        if( !validator.isNumeric(jsonData.phone.toString())
            || +jsonData.phone <= 0
        ) {
            jData.status = "error";
            jData.error = "wrong_phone";
            main.sendAckToWSClient(jData);
            return false;
        }

        // if( !jsonData.requestId || !validator.isNumeric(jsonData.requestId.toString())
        //     || jsonData.requestId == undefined ) {
        //     jData.status = "error";
        //     jData.error = "wrong_request_id";
        //     main.sendAckToWSClient(jData);
        //     return false;
        // }


        var q = 'SELECT id, name, address, business, position, requisites, phone, token ' +
            'FROM users WHERE phone="'+jsonData.phone+'" LIMIT 1';
        jsonData.query = q;
        jsonData.action = "authPhone";
        sendToQueue(jsonData);
    }

    function authSms(phone, code, cb) {

        //валидация входящих переменных
        if( !validator.isNumeric(phone.toString())
            || +phone <= 0
        ) {
            cb({status: "error", error:"wrong_phone"});
            return false;
        } else if( !validator.isNumeric(code.toString())
            || +code <= 0
        ) {
            cb({status: "error", error:"wrong_phone"});
            return false;
        }

        var phoneSMSCodeKey = phone+":"+code;

        redisClient.hget("authPhoneSMS", phoneSMSCodeKey, function(err, replyUserDataString) {
            //если смс-код не найден
            if(err || !replyUserDataString) {
                cb({status: "error", error:"wrong_sms_code"});
            } else {
                //если все ок
                //удаляем смс-код
                redisClient.hdel("authPhoneSMS", phoneSMSCodeKey, function(err, replyToken) {});
                cb({status: "ok", info:replyUserDataString});
            }
        });

    }

    function addAsset(params) {

        //для подтверждений, с ошибками или без
        var jData = {};
        jData.action = params.action;

        if( !params.requestId || !validator.isNumeric(params.requestId.toString())
            || params.requestId == undefined ) {
            jData.status = "error";
            jData.error = "wrong_request_id";
            main.sendAckToWSClient(jData);
            return false;
        }


        getUserIdByToken(params.token, function(user_id_phone) {

            jData.socketId = params.socketId;
            jData.requestId = params.requestId;

            //если токен не верен - возвращаем ошибку
            if(user_id_phone.id == -1) {
                jData.status = "error";
                jData.error = "wrong_token";
                main.sendAckToWSClient(jData);
                return false;
            }

            if( params.name == "" || params.name == undefined || params.name == 'temporary_asset' ) {
                jData.status = "error";
                jData.error = "wrong_name";
                main.sendAckToWSClient(jData);
                return false;
            }

            if( params.type != 'asset' && params.type != 'partner' ) {
                jData.status = "error";
                jData.error = "wrong_type";
                main.sendAckToWSClient(jData);
                console.log("err.params:", params.type != 'asset' , params.type != 'partner',
                    params.type != 'asset' && params.type != 'partner', params);
                return false;
            }

            if( params.name == "" || params.name == undefined ) {
                jData.status = "error";
                jData.error = "wrong_name";
                main.sendAckToWSClient(jData);
                return false;
            }

            params.name = mysql_real_escape_string(params.name);

            for(var item in params) {
                if(params[item] == undefined || params[item] == NaN) params[item] = "";
            }

            if(params.partnerPhone == undefined)params.partnerPhone = "";

            params.user_id = user_id_phone.id;
            params.myPhone = user_id_phone.phone;

            var isCost = params.isCost || 0;

            if( params.type == "asset" ) {
                //если актив типа "актив" и ему не нужно поле asset_id_in_partner, то делаем простой запрос
                var q = 'INSERT INTO assets(user_id, name, type, saldo, partner_phone, is_cost) ' +
                    'VALUES("'+ +params.user_id+'", "'+params.name+'", "'+params.type+'", "'+ +params.saldo+'", "'+
                    params.partnerPhone+'", '+isCost+')';
                params.query = q;
                sendToQueue(params);
            } else if(params.type == "partner") {

                if(user_id_phone.phone == params.partnerPhone) {
                    jData.status = "error";
                    jData.error = "you_cant_add_yourself_as_partner";
                    main.sendAckToWSClient(jData);
                    return false;
                }
                sendToQueue(params);
            }
        });
    }

    function deleteAsset(params) {

        var jData = {};
        jData.action = params.action;
        jData.requestId = params.requestId;

        if( !params.requestId || !validator.isNumeric(params.requestId.toString()) || params.requestId == undefined ) {
            jData.status = "error";
            jData.error = "wrong_request_id";
            main.sendAckToWSClient(jData);
            return false;
        }

        getUserIdByToken(params.token, function(user_id_phone) {
            //если токен не верен - возвращаем ошибку
            if(user_id_phone.id == -1) {

                jData.socketId = params.socketId;
                jData.status = "error";
                jData.error = "wrong_token";
                main.sendAckToWSClient(jData);
                return false;
            }

            for(var item in params) {
                if(params[item] == undefined) params[item] = "";
            }

            params.user_id = user_id_phone.id;
            sendToQueue(params);
        });
    }

    function transfer(params) {

        console.log('index(db).transfer', params);

        var jData = {};
        jData.action = params.action;
        jData.socketId = params.socketId;
        jData.requestId = params.requestId;


        params.comment1 = mysql_real_escape_string(params.comment1);
        params.comment2 = mysql_real_escape_string(params.comment2);

        //если клиент не указал 2-й коммент к транзакции - копируется 1-ый во 2-ой и отправляется
        if(params.comment2 == "" || params.comment2 == undefined || params.comment2 == null) {
            params.comment2 = params.comment1;
        }

        if( !params.requestId || !validator.isNumeric(params.requestId.toString()) || params.requestId == undefined ) {
            jData.status = "error";
            jData.error = "wrong_request_id";
            main.sendAckToWSClient(jData);
            return false;
        }

        getUserIdByToken(params.token, function(user_id_phone) {

            //если токен не верен - возвращаем ошибку
            if(user_id_phone.id == -1) {
                jData.status = "error";
                jData.error = "wrong_token";
                main.sendAckToWSClient(jData);
                return false;
            }

            //валидация входных параметров
            if( !validator.isNumeric(params.from.toString()) || +params.from <= 0 ) {
                jData.status = "error";
                jData.error = "wrong_from_parameter";
                main.sendAckToWSClient(jData);
                return false;
            }

            if( !validator.isNumeric(params.to.toString()) || +params.to <= 0 ) {
                jData.status = "error";
                jData.error = "wrong_to_parameter";
                main.sendAckToWSClient(jData);
                return false;
            }

            if(params.from == params.to) {
                jData.action = params.action;
                jData.socketId = params.socketId;
                jData.status = "error";
                jData.error = "could_not_transfer_to_self";
                main.sendAckToWSClient(jData);
                return false;
            }

            for(var item in params) {
                if(params[item] == undefined) params[item] = "";
            }

            params.user_id = user_id_phone.id;
            params.phone = user_id_phone.phone;
            params.myPhone = user_id_phone.phone;

            /*
            алгоритм работы:
            1. проверяем типы from и to активов
            1.1. если оба актива существуют для данного юзера - идем дальше. если нет - выдаем ошибку.
            2.1. если оба актива имеют тип "актив" - переводим средства с одного на другой,
                обновляем сальдо обоих активов.
                Аналогично - если один или оба актива имеют тип "категория расходов"
            3. если один из активов имеет тип "партнер", то:
                * определяем - мы переводим от себя или запрашиваем перевод к себе
                * если от себя к другому, то атамарно:
                     * ставим новое сальдо на активе "откуда",
                     * создаем 3 записи истории действий "перевод в процессе. from->to"
                      * одну запись для актива "откуда" данного юзера(отправителя)
                      * вторую запись для актива "куда" для данного юзера(актив-получатель)
                      * третью запись для актива-партнера у юзера-получателя
                    * обновляем состояние unconfirmed_deals у:
                      *   юзера-отправителя (актив "откуда")
                      *   юзера-получателя (актив "партнер")
                    * шлем пуш-уведомление партнеру-получателю
                    * ожидаем подтверждения от другого юзера(партнера)
                        * если получено подтверждение перевода, то:
                           * создаем 4-ую запись в истории действий:
                                * у юзера-получателя для актива-приемника ("получено")
                           * ставим новое сальдо у юзера-получателя, на активе-приемнике и на активе-партнере
                           * обновляем статусы у всех 4-х действий (из "в ожидании" на "переведено")
                           * обновляем состояние unconfirmed_deals у:
                                * юзера-отправителя (появился новый бейдж, т.к. появилось новое состояние)
                                * юзера-получателя (аналогично)
                           * (возможно) шлем пуш-уведомление партнеру-отправителю
                        * если перевод отклонен, то:
                           * обновляем 2 сальдо обратно, у юзера-отправителя (актив "откуда" и "куда" )
                           * обновляем статусы у всех 4-х действий в истории(из "в ожидании" на "отклонено")
                           * обновляем состояние unconfirmed_deals у:
                             * юзера-отправителя (появился новый бейдж, т.к. появилось новое состояние)
                             * юзера-получателя (аналогично)
                           * (возможно) шлем пуш-уведомление партнеру-отправителю
             4. если оба имеют тип "партнер", то:
             реализация: в воркере */

            // 1. проверяем типы from и to активов
            sendTransferToQueue(params);
        });
    }

    //юзер отклонил перевод
    function declineTransfer(params) {

        var jData = {};
        jData.action = params.action;
        jData.socketId = params.socketId;
        jData.requestId = params.requestId;

        if( !params.requestId || !validator.isNumeric(params.requestId.toString()) || params.requestId == undefined ) {
            jData.status = "error";
            jData.error = "wrong_request_id";
            main.sendAckToWSClient(jData);
            return false;
        }

        getUserIdByToken(params.token, function(user_id_phone) {

            //если токен не верен - возвращаем ошибку
            if(user_id_phone.id == -1) {
                jData.status = "error";
                jData.error = "wrong_token";
                main.sendAckToWSClient(jData);
                return false;
            }

            params.actionHash = mysql_real_escape_string(params.actionHash);

            params.user_id = user_id_phone.id;
            sendTransferToQueue(params);
        });
    }

    //юзер подтвердил перевод
    function acceptTransfer(params) {

        var jData = {};
        jData.action = params.action;
        jData.socketId = params.socketId;
        jData.requestId = params.requestId;

        if( !params.requestId || !validator.isNumeric(params.requestId.toString()) || params.requestId == undefined ) {
            jData.status = "error";
            jData.error = "wrong_request_id";
            main.sendAckToWSClient(jData);
            return false;
        }

        getUserIdByToken(params.token, function(user_id_phone) {

            //если токен не верен - возвращаем ошибку
            if(user_id_phone.id == -1) {
                jData.status = "error";
                jData.error = "wrong_token";
                main.sendAckToWSClient(jData);
                return false;
            }

            if( !validator.isNumeric(params.transferAssetId.toString()) || +params.transferAssetId <= 0 ) {
                jData.status = "error";
                jData.error = "wrong_transfer_asset_id_parameter";
                main.sendAckToWSClient(jData);
                return false;
            }

            params.actionHash = mysql_real_escape_string(params.actionHash);

            params.user_id = user_id_phone.id;
            sendTransferToQueue(params);
        });
    }

    //authed-user-api block code [ONLY with token]
    //отправляем юзеру его активы(включая партнеров)
    function getAssets(params) {

        var jData = {};
        jData.action = params.action;
        jData.socketId = params.socketId;
        jData.requestId = params.requestId;

        if( !params.requestId || !validator.isNumeric(params.requestId.toString()) || params.requestId == undefined ) {
            jData.status = "error";
            jData.error = "wrong_request_id";
            main.sendAckToWSClient(jData);
            return false;
        }

        getUserIdByToken(params.token, function(user_id_phone) {

            console.log(params.token, user_id_phone);

            //если токен не верен - возвращаем ошибку
            if(user_id_phone.id == -1) {
                jData.status = "error";
                jData.error = "wrong_token";
                main.sendAckToWSClient(jData);
                return false;
            }

            params.user_id = user_id_phone.id;

            sendToQueue(params);

        });

    }

    function getAssetHistory(params) {

        var jData = {};
        jData.action = params.action;
        jData.socketId = params.socketId;
        jData.requestId = params.requestId;

        if( !params.requestId || !validator.isNumeric(params.requestId.toString()) || params.requestId == undefined ) {
            jData.status = "error";
            jData.error = "wrong_request_id";
            main.sendAckToWSClient(jData);
            return false;
        }

        getUserIdByToken(params.token, function(user_id_phone) {

            //если токен не верен - возвращаем ошибку
            if(user_id_phone.id == -1) {
                jData.status = "error";
                jData.error = "wrong_token";
                main.sendAckToWSClient(jData);
                return false;
            }

            if(!validator.isNumeric(params.assetId.toString()) || +params.assetId <=0  ) {
                jData.status = "error";
                jData.error = "wrong_asset_id_parameter";
                main.sendAckToWSClient(jData);
                return false;
            }

            if(!validator.isNumeric(params.offset.toString()) ) {
                jData.status = "error";
                jData.error = "wrong_offset_parameter";
                main.sendAckToWSClient(jData);
                return false;
            }

            params.user_id = user_id_phone.id;
            sendToQueue(params);
        });
    }

    function renameAsset(params) {

        var jData = {};
        jData.action = params.action;
        jData.socketId = params.socketId;
        jData.requestId = params.requestId;

        if( !params.requestId || !validator.isNumeric(params.requestId.toString()) || params.requestId == undefined ) {
            jData.status = "error";
            jData.error = "wrong_request_id";
            main.sendAckToWSClient(jData);
            return false;
        }

        getUserIdByToken(params.token, function(user_id_phone) {
            //если токен не верен - возвращаем ошибку
            if(user_id_phone.id == -1) {
                jData.status = "error";
                jData.error = "wrong_token";
                main.sendAckToWSClient(jData);
                return false;
            }

            if(!validator.isNumeric(params.assetId.toString()) || +params.assetId <=0  ) {
                jData.status = "error";
                jData.error = "wrong_asset_id_parameter";
                main.sendAckToWSClient(jData);
                return false;
            }

            params.newName = mysql_real_escape_string(params.newName);

            var q = 'UPDATE assets SET name="'+params.newName+'" WHERE id='+params.assetId+' ' +
                'AND user_id='+user_id_phone.id;
            params.user_id = user_id_phone.id;
            params.query = q;
            sendToQueue(params);
        });
    }

    /****************************PROFILE****************************/
    function setProfile(params) {

        var jData = {};
        jData.action = params.action;
        jData.socketId = params.socketId;
        jData.requestId = params.requestId;

        if( !params.requestId || !validator.isNumeric(params.requestId.toString()) || params.requestId == undefined ) {
            jData.status = "error";
            jData.error = "wrong_request_id";
            main.sendAckToWSClient(jData);
            return false;
        }

        getUserIdByToken(params.token, function(user_id_phone) {

            //если токен не верен - возвращаем ошибку
            if(user_id_phone.id == -1) {
                jData.status = "error";
                jData.error = "wrong_token";
                main.sendAckToWSClient(jData);
                return false;
            }

            params.name =  mysql_real_escape_string(params.name);
            params.address = mysql_real_escape_string(params.address);
            params.business = mysql_real_escape_string(params.business);
            params.position = mysql_real_escape_string(params.position);
            params.requisites = mysql_real_escape_string(params.requisites);
            params.city = mysql_real_escape_string(params.city);
            params.company = mysql_real_escape_string(params.company);

            if(!params.name) params.name= "";
            if(!params.address) params.address= "";
            if(!params.business) params.business = "";
            if(!params.position) params.position = "";
            if(!params.requisites) params.requisites = "";
            if(!params.city) params.city = "";
            if(!params.company) params.company = "";

            var q = 'UPDATE users SET name="'+params.name+'", ' +
                'address="'+params.address+'", ' +
                "business='"+params.business+"', " +
                "position='"+params.position+"', " +
                "requisites='"+params.requisites+"', " +
                "city='"+params.city+"', " +
                "company='"+params.company+"' " +
                'WHERE id='+user_id_phone.id;

            params.user_id = user_id_phone.id;
            params.phone = user_id_phone.phone;
            params.query = q;
            sendToQueue(params);
        });
    }

    function getProfile(params) {

        var jData = {};
        jData.action = params.action;
        jData.socketId = params.socketId;
        jData.requestId = params.requestId;

        if( !params.requestId || !validator.isNumeric(params.requestId.toString()) || params.requestId == undefined ) {
            jData.status = "error";
            jData.error = "wrong_request_id";
            main.sendAckToWSClient(jData);
            return false;
        }

        //сперва пробуем получить данные из кэша
        redisClient.hget("users", params.userPhone, function (redisErr, redisReply) {
            //если данные не были получены из кэша
            if(redisErr || !redisReply) {

                getUserIdByToken(params.token, function(user_id_phone) {

                    //если токен не верен - возвращаем ошибку
                    if(user_id_phone.id == -1) {
                        jData.status = "error";
                        jData.error = "wrong_token";
                        main.sendAckToWSClient(jData);
                        return false;
                    }

                    if( !params || !params.userPhone || !validator.isNumeric(params.userPhone.toString()) ) {
                        jData.status = "error";
                        jData.error = "wrong_user_phone_parameter";
                        main.sendAckToWSClient(jData);
                        return false;
                    }

                    var q = 'SELECT name, address, business, position, requisites, city, company, goods, ' +
                        'phone FROM users ' +
                        'WHERE phone='+params.userPhone+" LIMIT 1";

                    params.user_id = user_id_phone.id;
                    params.query = q;
                    sendToQueue(params);
                });

           } else {
                //если все ок, данные получены из кэша
                //отправляем подтверждение клиенту
                var jDataAck = {};
                jDataAck.action = params.action;
                jDataAck.socketId = params.socketId;
                jDataAck.status = "ok";
                main.sendAckToWSClient(jDataAck);

                var redisJsonData = JSON.parse(redisReply);

                delete redisJsonData['id'];
                delete redisJsonData['token'];
                delete redisJsonData['pushToken'];
                delete redisJsonData['user_id'];

                var userProfile = redisJsonData;

                var jData = {};
                jData.info = userProfile;
                jData.action = "getProfile";
                jData.socketId = params.socketId;

                sendQueueToWSClient(jData);
           }
        });
    }
    /************************END PROFILE****************************/

    /*********************SET PUSH TOKEN*****************************/
    function setPushToken(params) {

        console.log('index.setPushToken', params.pushToken);

        var jData = {};
        jData.action = params.action;
        jData.socketId = params.socketId;
        jData.requestId = params.requestId;

        if( !params.requestId || !validator.isNumeric(params.requestId.toString()) || params.requestId == undefined ) {
            jData.status = "error";
            jData.error = "wrong_request_id";
            main.sendAckToWSClient(jData);
            return false;
        }

        getUserIdByToken(params.token, function(user_id_phone) {

            //если токен не верен - возвращаем ошибку
            if(user_id_phone.id == -1) {
                jData.status = "error";
                jData.error = "wrong_token";
                main.sendAckToWSClient(jData);
                return false;
            }

            if(!params.pushToken || params.pushToken == "") {

                jData.action = params.action;
                jData.socketId = params.socketId;
                jData.status = "error";
                jData.error = "wrong_pushToken_param";
                main.sendAckToWSClient(jData);
                return false;
            }

            params.pushToken = mysql_real_escape_string(params.pushToken);

            //обновляем запись в кэше
            redisClient.hget("users", params.token, function (err, reply) {
                if(err || !reply) {
                    //ничего не делаем, если юзер не найден
                } else {
                    //если все ок
                    var jsonData = JSON.parse(reply);
                    jsonData.pushToken = params.pushToken;
                    var jsonDataString = JSON.stringify(jsonData);
                    redisClient.hset("users", params.token, jsonDataString);
                }
            });

            //определяем, в какую ячейку записываем пуш-токен
            var q;
            if(!params.device || params.device == undefined || params.device == "ios") {
                q = 'UPDATE users SET pushToken="'+params.pushToken+'" ' +
                    'WHERE id='+user_id_phone.id;
            } else if(params.device == "android") {
                var q = 'UPDATE users SET pushTokenGCM="'+params.pushToken+'" ' +
                    'WHERE id='+user_id_phone.id;
            }

            params.user_id = user_id_phone.id;
            params.phone = user_id_phone.phone;
            params.query = q;
            sendToQueue(params);

        });
    }
    /*******************END SET PUSH TOKEN***************************/

    /**********************SALDO ZONE********************************/
    function setSaldo(params) {

        var jData = {};
        jData.action = params.action;
        jData.socketId = params.socketId;
        jData.requestId = params.requestId;

        if( !params.requestId || !validator.isNumeric(params.requestId.toString()) || params.requestId == undefined ) {
            jData.status = "error";
            jData.error = "wrong_request_id";
            main.sendAckToWSClient(jData);
            return false;
        }

        getUserIdByToken(params.token, function(user_id_phone) {

            //если токен не верен - возвращаем ошибку
            if(user_id_phone.id == -1) {
                jData.status = "error";
                jData.error = "wrong_token";
                main.sendAckToWSClient(jData);
                return false;
            }

            if(!validator.isNumeric(params.assetId.toString()) || +params.assetId <= 0 ) {
                jData.status = "error";
                jData.error = "wrong_asset_id_parameter";
                main.sendAckToWSClient(jData);
                return false;
            }

            if(!validator.isNumeric(params.newSaldo.toString())) {
                jData.status = "error";
                jData.error = "wrong_new_saldo_parameter";
                main.sendAckToWSClient(jData);
                return false;
            }


            params.user_id = user_id_phone.id;
            params.phone = user_id_phone.phone;
            sendTransferToQueue(params);
        });
    }

    //юзер подтвердил перевод
    function acceptNewSaldo(params) {

        var jData = {};
        jData.action = params.action;
        jData.socketId = params.socketId;
        jData.requestId = params.requestId;

        if( !params.requestId || !validator.isNumeric(params.requestId.toString()) || params.requestId == undefined ) {
            jData.status = "error";
            jData.error = "wrong_request_id";
            main.sendAckToWSClient(jData);
            return false;
        }

        getUserIdByToken(params.token, function(user_id_phone) {

            //если токен не верен - возвращаем ошибку
            if(user_id_phone.id == -1) {
                jData.status = "error";
                jData.error = "wrong_token";
                main.sendAckToWSClient(jData);
                return false;
            }

            params.actionHash = mysql_real_escape_string(params.actionHash);

            params.user_id = user_id_phone.id;
            sendTransferToQueue(params);
        });
    }

    //юзер отклонил перевод
    function declineNewSaldo(params) {

        var jData = {};
        jData.action = params.action;
        jData.socketId = params.socketId;
        jData.requestId = params.requestId;

        if( !params.requestId || !validator.isNumeric(params.requestId.toString()) || params.requestId == undefined ) {
            jData.status = "error";
            jData.error = "wrong_request_id";
            main.sendAckToWSClient(jData);
            return false;
        }

        getUserIdByToken(params.token, function(user_id_phone) {

            //если токен не верен - возвращаем ошибку
            if(user_id_phone.id == -1) {
                jData.status = "error";
                jData.error = "wrong_token";
                main.sendAckToWSClient(jData);
                return false;
            }

            params.actionHash = mysql_real_escape_string(params.actionHash);

            params.user_id = user_id_phone.id;

            sendTransferToQueue(params);
        });

    }
    /********************END SALDO ZONE******************************/

    /******************STATUS ZONE***********************************/
    function ionline(params) {

        var jData = {};
        jData.action = params.action;
        jData.socketId = params.socketId;
        jData.requestId = params.requestId;

        if( !params.requestId || !validator.isNumeric(params.requestId.toString()) || params.requestId == undefined ) {
            jData.status = "error";
            jData.error = "wrong_request_id";
            main.sendAckToWSClient(jData);
            return false;
        }

        getUserIdByToken(params.token, function (jsonData) {

            if(jsonData.id == -1) {
                jData.status = "error";
                jData.error = "wrong_token";
                main.sendAckToWSClient(jData);
            } else {
                //remove from offline
                redisClient.hdel("offline", jsonData.phone, function (er, repl) {});
                //add to online
                redisClient.hset("online", jsonData.id, params.socketId);
                redisClient.hset("online", params.socketId, jsonData.id);

                jData.status = "ok";
                main.sendAckToWSClient(jData);
            }
        });

    }
    /********************END STATUS ZONE*****************************/


    /********************TEMPORARY ASSET ZONE************************/
    function transferFromTemporaryAsset2Asset(params) {

        var jData = {};
        jData.action = params.action;
        jData.socketId = params.socketId;
        jData.requestId = params.requestId;

        if( !params.requestId || !validator.isNumeric(params.requestId.toString()) || params.requestId == undefined ) {
            jData.status = "error";
            jData.error = "wrong_request_id";
            main.sendAckToWSClient(jData);
            return false;
        }

        getUserIdByToken(params.token, function(user_id_phone) {

            //если токен не верен - возвращаем ошибку
            if(user_id_phone.id == -1) {
                jData.status = "error";
                jData.error = "wrong_token";
                main.sendAckToWSClient(jData);
                return false;
            }

            if(params.to == params.from) {
                jData.status = "error";
                jData.error = "could_not_transfer_to_self";
                main.sendAckToWSClient(jData);
                return false;
            }


            if(!validator.isNumeric(params.to.toString()) || +params.to <= 0 ) {
                jData.status = "error";
                jData.error = "wrong_to_parameter";
                main.sendAckToWSClient(jData);
                return false;
            }

            if(!validator.isNumeric(params.from.toString()) || +params.from <= 0 ) {
                jData.status = "error";
                jData.error = "wrong_from_parameter";
                main.sendAckToWSClient(jData);
                return false;
            }

            params.actionHash = mysql_real_escape_string(params.actionHash);

            params.user_id = user_id_phone.id;
            sendTransferToQueue(params);
        });

    }

    function deleteFromTemporaryAsset(params) {

        var jData = {};
        jData.action = params.action;
        jData.socketId = params.socketId;
        jData.requestId = params.requestId;

        if( !params.requestId || !validator.isNumeric(params.requestId.toString()) || params.requestId == undefined ) {
            jData.status = "error";
            jData.error = "wrong_request_id";
            main.sendAckToWSClient(jData);
            return false;
        }

        getUserIdByToken(params.token, function(user_id_phone) {

            //если токен не верен - возвращаем ошибку
            if(user_id_phone.id == -1) {
                jData.status = "error";
                jData.error = "wrong_token";
                main.sendAckToWSClient(jData);
                return false;
            }

            params.actionHash = mysql_real_escape_string(params.actionHash);

            params.user_id = user_id_phone.id;
            sendTransferToQueue(params);
        });

    }

    /********************END TEMPORARY ASSET ZONE********************/


    /*********************GOODS ZONE*********************************/
    function updateGoods(params) {

        var jData = {};
        jData.action = params.action;
        jData.socketId = params.socketId;
        jData.requestId = params.requestId;

        if( !params.requestId || !validator.isNumeric(params.requestId.toString()) || params.requestId == undefined ) {
            jData.status = "error";
            jData.error = "wrong_request_id";
            main.sendAckToWSClient(jData);
            return false;
        }

        getUserIdByToken(params.token, function(user_id_phone) {

            //если токен не верен - возвращаем ошибку
            if(user_id_phone.id == -1) {
                jData.status = "error";
                jData.error = "wrong_token";
                main.sendAckToWSClient(jData);
                return false;
            }

            //INFO: здесь нет какой-либо дополнительной валидации. В будущем данный метод возможно
            // будет реализован по другому(разные поля в разных таблицах, чтобы можно было проводить поиск),
            // и валидацию нужно будет добавить туда
            var goodsString = JSON.stringify(params.goods);

            console.log("goods", typeof params.goods, params.goods);

            var q = "UPDATE users SET goods='"+goodsString+"' WHERE id="+user_id_phone.id;
            params.user_id = user_id_phone.id;
            params.user_phone = user_id_phone.phone;
            params.query = q;
            params.goods = goodsString;
            sendToQueue(params);
        });
    }
    /************************END GOODS ZONE**************************/

    /*********************DELETE TRANSACTIONS HISTORY****************/
    function deleteTransactionsHistory(params) {

        var jData = {};
        jData.action = params.action;
        jData.socketId = params.socketId;
        jData.requestId = params.requestId;

        if( !params.requestId || !validator.isNumeric(params.requestId.toString()) || params.requestId == undefined ) {
            jData.status = "error";
            jData.error = "wrong_request_id";
            main.sendAckToWSClient(jData);
            return false;
        }

        getUserIdByToken(params.token, function(user_id_phone) {

            //если токен не верен - возвращаем ошибку
            if(user_id_phone.id == -1) {
                jData.status = "error";
                jData.error = "wrong_token";
                main.sendAckToWSClient(jData);
                return false;
            }

            for(var i=0; i< params.actionsIds.length; i++) {
                if( !validator.isNumeric(params.actionsIds[i].toString()) || +params.actionsIds[i] <=0 ) {
                    jData.status = "error";
                    jData.error = "wrong_actions_ids_parameter";
                    main.sendAckToWSClient(jData);
                    return false;
                    break;
                }
            }

            params.user_id = user_id_phone.id;
            params.user_phone = user_id_phone.phone;
            params.actionsIds = params.actionsIds;
            sendToQueue(params);
        });
    }
    /*******************END DELETE TRANSACTIONS HISTORY**************/

    /********************DELETE ACCOUNT******************************/
    function deleteAccount(params) {

        console.log("deleteAccount called");

        var jData = {};
        jData.action = params.action;
        jData.socketId = params.socketId;
        jData.requestId = params.requestId;

        if( !params.requestId || !validator.isNumeric(params.requestId.toString()) || params.requestId == undefined ) {
            jData.status = "error";
            jData.error = "wrong_request_id";
            main.sendAckToWSClient(jData);
            return false;
        }

        getUserIdByToken(params.token, function(user_id_phone) {

            //если токен не верен - возвращаем ошибку
            if(user_id_phone.id == -1) {
                jData.status = "error";
                jData.error = "wrong_token";
                main.sendAckToWSClient(jData);
                return false;
            }

            params.user_id = user_id_phone.id;
            params.user_token = params.token;
            params.user_phone = user_id_phone.phone;

            sendToQueue(params);
        });
    }
    /*******************END DELETE ACCOUNT***************************/



    //end authorized-user-api block code
    function getUserIdByToken(token, cb) {

        redisClient.hget("users",token, function(redisErr, redisReply) {
            // запись в кэше не найдена или произошла ошибка
            if(redisErr || !redisReply) {
                //запрашиваем данные из mysql
                pool.getConnection(function(err, connection) {
                    var id, phone;
                    var q = 'SELECT id, phone FROM users WHERE token="'+token+'" LIMIT 1';
                    try {
                        connection.query( q, function(err, rows) {
                            if(err) {
                                console.log( colors.red("db.err"), err.code);
                                id = -1;
                                phone = -1;
                            } else {
                                //все ок
                                if(rows.length == 0) {
                                    id = -1;
                                    phone = -1;
                                } else {
                                    id = rows[0].id;
                                    phone = rows[0].phone;
                                }
                            }
                            connection.release();
                            cb({id:id,phone:phone});
                        });
                    } catch(e) {
                        console.log( colors.red("error catched:"), e);
                        cb("error");
                    }
                });
           } else {
                //все ок
                var jsonRedisData = JSON.parse(redisReply);
                var userId = jsonRedisData.id;
                var userPhone = jsonRedisData.phone;
                cb({id:userId,phone:userPhone});

            }

        });

    }

    //отправка сообщений в очередь
    function sendToQueue(jsonData) {
        var jsonDataString = JSON.stringify(jsonData);
        rabbit.then(function(connection) {
            var ok = connection.createChannel();
            ok.then(function(channel) {
                // durable: true is set by default
                channel.assertQueue("messages");
                channel.assertExchange("incoming");
                channel.bindQueue("messages", "incoming", "mda");
                channel.publish("incoming", "mda", new Buffer(jsonDataString), {deliveryMode: false});
                return ok;
            }).
            then(null, console.log);
            return ok;
        }).
        then(null, console.log);
    }

    function sendTransferToQueue(params) {

        var jsonDataString = JSON.stringify(params);
        rabbit.then(function(connection) {
            var ok = connection.createChannel();
            ok.then(function(channel) {
                // durable: true is set by default
                channel.assertQueue("messagesTransfer");
                channel.assertExchange("incomingTransfer");
                channel.bindQueue("messagesTransfer", "incomingTransfer", "mda");
                channel.publish("incomingTransfer", "mda", new Buffer(jsonDataString), {deliveryMode: false});
                return ok;
            }).
            then(null, console.log);
            return ok;
        }).
        then(null, console.log);
    }

    /**
     * Отправляем в очередь команду по добавлению партнера
     */
    function sendToQueueAddPartnerCommand(jsonData) {
        jsonData.typeAsset = "partner";
        var jsonDataString = JSON.stringify(jsonData);
        rabbit.then(function(connection) {
            var ok = connection.createChannel();
            ok.then(function(channel) {
                // durable: true is set by default
                channel.assertQueue("messages");
                channel.assertExchange("incoming");
                channel.bindQueue("messages", "incoming", "mda");
                channel.publish("incoming", "mda", new Buffer(jsonDataString), {deliveryMode: false});
                return ok;
            }).
            then(null, console.log);
            return ok;
        }).
        then(null, console.log);
    }

    /**
     * отправляем ответ сразу ws-клиенту (обычно для случаев, когда данные были взяты из redis-кэша)
     */
    function sendQueueToWSClient(jsonData) {

        rabbit2.then(function(connection) {
            var ok = connection.createChannel();

            ok.then(function(channel) {
                // durable: true is set by default
                channel.assertQueue("infoMessages");
                channel.assertExchange("info");
                channel.bindQueue("infoMessages", "info", "mda");

                var jsonDataString = JSON.stringify(jsonData);

                channel.publish("info", "mda", new Buffer(jsonDataString), {deliveryMode: false});
                return ok;
            }).
            then(null, console.log);

            return ok;
        }).
        then(null, console.log);
    }


    /**
     * Загрузка актуальных данных юзеров в RAM
     */
    function redisCacheUpdate() {

        //1. удаляем все имеющиеся записи в redis
        console.log( colors.green("clear users..."));
            redisClient.hdel("users", function (err, reply) {});
        console.log( colors.green("ok"));
        console.log( colors.green("clear phoneToken..."));
            redisClient.hdel("phoneToken", function (err, reply) {});
        console.log( colors.green("ok"));
        console.log( colors.green("clear authPhoneSMS..."));
            redisClient.hdel("authPhoneSMS", function (err, reply) {});
        console.log( colors.green("ok"));
        console.log( colors.green("clear partnerId2pushToken..."));
            redisClient.hdel("partnerId2pushToken", function (err, reply) {});
        console.log( colors.green("ok"));


        console.log( colors.green("clear partnersUsers..."));
            redisClient.hdel("partnersUsers", function (err, reply) {});
        console.log( colors.green("ok"));


        console.log( colors.green("clear usersPartners..."));
            // redisClient.hdel("usersPartners", function (err, reply) {});
        console.log( colors.green("ok"));

            redisClient.flushall(function (e,r) {
                console.log(e, r);
            });

        pool.getConnection(function(err, connection) {
            var id;
            var q = 'SELECT id, name, address, business, position, requisites, city, company,' +
                ' goods, phone, token, pushToken ' +
                'FROM users';

            try {
                connection.query( q, function(err, rows) {
                    if(err) {
                        console.log( colors.red("db.err"), err.code);
                        id = -1;
                    } else {
                        if(rows.length == 0) {
                            console.log( colors.red("db.err: length=0"));
                        } else {
                            var users = {};

                            for(var i = 0; i< rows.length; i++) {

                                var _goods;

                                try {
                                    _goods = rows[i].goods != "" && rows[i].goods != null &&
                                    rows[i].goods != undefined ? JSON.parse(rows[i].goods) : [];
                                } catch( ex ) {
                                    console.error("ex: ", ex);
                                    _goods = [];
                                }

                                var userObj = {
                                    id: rows[i].id,
                                    name: rows[i].name,
                                    address: rows[i].address,
                                    business: rows[i].business,
                                    position: rows[i].position,
                                    requisites: rows[i].requisites,
                                    city: rows[i].city,
                                    company: rows[i].company,
                                    goods: _goods,
                                    phone: rows[i].phone,
                                    token: rows[i].token,
                                    pushToken: rows[i].pushToken
                                };

                                var phoneForAuth = rows[i].phone;
                                var tokenForAuth = rows[i].token;


                                //записываем в users<token> id и phone
                                //TODO: эту запись возможно надо уже удалить, за ненадобностью
                                var byTokenJsonData = {id: rows[i].id, phone: rows[i].phone, token: rows[i].token};
                                var byTokenJsonDataString = JSON.stringify(byTokenJsonData);
                                redisClient.hset("users", tokenForAuth, byTokenJsonDataString);

                                //записываем в users<phone> данные всех пользователей
                                var jsonUserObj = JSON.stringify(userObj);
                                redisClient.hset("users", phoneForAuth, jsonUserObj);

                                //записываем в id2phone user_id->phone(для таблицы offline)
                                redisClient.hset("id2phone", rows[i].id, rows[i].phone);

                            }

                        }
                    }
                    connection.release();
                    // cb(id);
                });
            } catch(e) {
                console.error("error catched: ", e);
            }
        });


        //записываем данные о связях partnerId и userId (как суб-данные для отправки ws-уведомлений)
        pool.getConnection(function(err, connection) {

            var q = "SELECT id, user_id FROM assets WHERE type='partner'";

            var partnerAssetIdAndUserId = [];
            var userIdAndPartnerAssetId = [];

            try {

                connection.query(q, function (err, rows) {
                    if (err) {
                        console.log(colors.red("db.err"), err.code);
                        id = -1;
                    } else {
                        //если все ок
                        //iNFO: префикс "key" используется чтобы сделать массив ассоциативным, а не обычным
                        //т.к. js автоматически преобразует типы и сводит просто цифровую строку к типу Number
                            for(var i = 0; i < rows.length; i++) {

                                var index = "key"+rows[i].id.toString();
                                var value = rows[i].user_id.toString();

                                if(!partnerAssetIdAndUserId[index] ) {
                                    partnerAssetIdAndUserId[index] = [];
                                    partnerAssetIdAndUserId[index].push(value);
                                } else {
                                    partnerAssetIdAndUserId[index].push(value);
                                }

                                var index2 = "key"+rows[i].user_id.toString();
                                var value2 = rows[i].id.toString();

                                // if(!userIdAndPartnerAssetId[index2] ) {
                                //     userIdAndPartnerAssetId[index2] = [];
                                //     userIdAndPartnerAssetId[index2].push(value2);
                                // } else {
                                //     userIdAndPartnerAssetId[index2].push(value2);
                                // }

                            }
                        }

                        /*for(var item in userIdAndPartnerAssetId) {
                            var key = item.substr(3).toString();
                            redisClient.hset("usersPartners", key, userIdAndPartnerAssetId[item].toString());
                        }*/


                        //для isOnline в worker'е
                        for(var item in partnerAssetIdAndUserId) {
                            var key = item.substr(3).toString();
                            redisClient.hset("partnersUsers", key, partnerAssetIdAndUserId[item].toString());
                        }

                });
            } catch(e) {
                console.error("error catched 1:", e);
            }

        });

        //записываем данные в userParnters (для отправки ws-сообщений о транзакциях,
        //чат-сообщениях, а так же статусах пользователей

        //for "partnerId2pushToken" redis table
        pool.getConnection(function(err, connection) {
            var id;

            var q = 'SELECT users.pushToken as pushToken,  assets.id as id FROM users ' +
                'LEFT JOIN assets ON users.phone=assets.partner_phone ' +
                'WHERE assets.type="partner"';

            try {
                connection.query( q, function(err, rows) {
                    if(err) {
                        console.log( colors.red("db.err2"), err.code);
                        id = -1;
                    } else {
                        if(rows.length == 0) {
                            console.log( colors.red("db.err2: length=0"));
                        } else {
                            for(var i = 0; i < rows.length; i++) {
                                var partnerId = rows[i].id;
                                var pushToken = rows[i].pushToken;
                                redisClient.hset("partnerId2pushToken", partnerId, pushToken);
                            }
                        }
                    }
                    connection.release();
                });
            } catch(e) {
                console.error("error catched: ", e);
            }
        });

    }

    //utils
    function mysql_real_escape_string(str) {
        if(!str || str == undefined) return "";
        return str.replace(/[\0\x08\x09\x1a\n\r"'\\\%]/g, function (char) {
            switch (char) {
                case "\0":
                    return "\\0";
                case "\x08":
                    return "\\b";
                case "\x09":
                    return "\\t";
                case "\x1a":
                    return "\\z";
                case "\n":
                    return "\\n";
                case "\r":
                    return "\\r";
                case "\"":
                case "'":
                case "\\":
                case "%":
                    return "\\"+char; // prepends a backslash to backslash, percent,
                                      // and double/single quotes
            }
        });
    }

})();

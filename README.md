# API v3 [WebSocket] #
Для проекта web/android/ios-приложения "Партнер"

### Что это? ###
Полнофункциональный сервер, позволяющий регистрировать и авторизировать пользователей, и затем (для авторизированных пользователей, имеющих токен авторизации) позволяющий вызывать пользовательские методы API.

### Серверы ###
Production - [ip скрыт]

### Как установить, запустить и остановить? ###
* Установить [NodeJS версии 4.4.4+](https://nodejs.org/).
* Выгрузить код из данного репозитория
* Установить необходимые библиотеки ``npm i``.
```
```
* В файле **.env** настроить переменные для доступа к базе данных MySQL, указать нужный порт для WS-сервера (рекомендуется порт 80).
* Для подключения к серверу установить [Putty](http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html).

    Для доступа к файловой системе использовать команду ``mc`` (Ctrl+O чтобы свернуть и развернуть).

    Для восстановления при падении и запуска сервера установить ``npm install -g forever``.

    ``forever start main.js`` для запуска сервера.

    ``forever stop main.js`` для остановки сервера.

    ``forever list`` для просмотра запущенных процессов.

    ``node main.js`` для тестирования и интерактивного просмотра логов.

* Для подключения к MySQL-базе данных установить [OpenServer](http://open-server.ru/download/) (если установлен Skype, в настройках соединения снять галочку с использования портов 80 и 443), в нем открыть MySQL менеджер (вкладка «Дополнительно»).
* Для подключения к NoSQL-базе данных установить [Redis Desktop Manager](http://redisdesktop.com/) или [Keylord](https://protonail.com/products/keylord), или другой Redis-менеджер.

###Важное замечание по терминам: ###

* термин **клиент** всегда обозначает клиент-приложение (отправитель запросов, в клиент-серверной архитектуре сетевых приложений).
* термины **пользователь** и **юзер** имеют везде одинаковый смысл и обозначают человека, пользующегося данным ПО.
* обозначение **с->s** (или **s<-c**) говорит об отправке сообщения/команды от клиента к серверу.
* обозначение **s->c** (или **c<-s**) говорит об отправке сообщения/команды от сервера к клиенту.
* обозначение **s->s** говорит об отправке сообщения/команды от сервера к другому серверу.
* обозначение **s<->s** говорит о возможности двух серверов обмениваться данными друг с другом.

### Принцип работы ###

* Сервер создает постоянное полнодуплексное ws-соединение между сервером и клиентом.

* Сервер может одновременно поддерживать тысячи ws-подключений (до **65536** для одного Debian-сервера, при использовании перед запуском сервера команды _ulimit -n 65536_, которая разрешает серверу создавать одновременно 65536 соединений).

* Клиент подключается к серверу и между ними устанавливается постоянное двустороннее соединение.

* Клиент может отправить команду серверу, и сервер может отправить команду клиенту.

* И сервер и клиент используют 3 типа сообщений: **Команды**, **Подтверждения** и **Сообщения об ошибках**.

* **Команды** представляют собой указание другой стороне выполнить определенное действие и/или прислать определенную информацию командующей стороне (ею может быть как клиент, так и сервер).

* **Шаблон команд** сервер<->клиент выглядит так: 
    `socket.emit("<action_name>",{info:{<msg>} })`
    , где _<action_name>_ - {String}, наименование отправляемой команды, 
    _<msg>_ - {Object | String} - параметры к команде (обычно в виде json-объекта). 
    Подробнее см. в разделе _"Примеры использования команд"_.

* **Подтверждения** представляют собой информацию о том, что команда была получена и выполнена, с ошибкой или без. _Подтверждения не содержат никакой другой информации, кроме сообщения о том, что команда была получена!_.

* Подтверждения нужны для того, чтобы командующая сторона была уверена, что ее команда была отправлена и получена. Если командующая сторона не получила подтверждения, то через некоторое время она должна **самостоятельно** попытаться отправить **ту же самую команду** повторно.

* **Подтверждения.** После получения команды, получатель отправляет отправителю подтверждение, что команда была получена. Если отправитель не получил подтверждение, то он должен попытаться отправить команду повторно. Подробнее см. в разделе _"Примеры использования подтверждений"_.

* **Подтверждения** всегда имеют статус. Пример: `{status:"ok"}` - команда выполнена успешно. `{status:"error"}` - команда выполнена с ошибкой (обычно это означает, что отправитель должен повторно отправить ту же самую команду).

* **Сообщения об ошибках** - представляют собой **часть подтверждений**. Если на другой стороне команда была выполнена с ошибкой, то в ответ вместе с подтверждением придет информация об ошибке. То есть, пример из предыдущего пункта в действительности может выглядеть так: `{status:"error", error:"user_not_found"}`.

* **Шаблон сообщений об ошибках**: `socket.emit("ack", {status:"error", error:"<string>"})`, где _<string>_ - текстовый код ошибки (например _"user_not_found"_).

* **Соглашение о выборе названий команд:** для именования ВСЕХ параметров ws-запросов следует придерживаться "верблюжей" нотации.
Пример: _"getAssets_" - правильно, _"get_assets"_ - не правильно.

### Как пользоваться (Client API)? ###

1.    Подключаемся (клиенты имеют "из коробки" событие "подключение установлено", которым он сообщает об успешном подключении).

1.    Если токен авторизации не был получен - получаем его:
    `socket.emit("authPhone", {phone:<phone_number>}` - команда сообщает серверу, что юзер с таким номером телефона хочет     подключиться. 

    В ответ сервер пришлет подтверждение _{status:"ok"}_ , либо _{status:"error", error:"user_not_found"}_. В первом клиент может переходить к вводу смс-кода, который сервер отправит ему на указанный номер(для тестов можно вводить 999999).

    Во втором случае клиенту следует перейти к окну регистрации пользователя (либо зарегистрировать пользователя автоматически, без ведома пользователя).

1.    Если пользователя не существует - регистрируем его:
    `socket.emit("regPhone",{phone:<phone_number>})`
    При регистрации так же придет подтверждение от сервера `{"ack", {status:"ok"}}` . И затем можно повторно провести авторизацию     (это так же можно выполнить незаметно для пользователя).

1.    После прихода подтверждения об успешной отправке команды `authPhone` нужно выполнить команду _authSms_: `socket.emit("authSms", {phone:<phone_number>, code:<sms_code>});`


1.    В случае успешной авторизации сервер пришлет команду `setToken`, в которой будет содержаться token. (Токен **НЕ придет в _Подтверждении_** успешного вызова команды `authSms`!)

1.    Далее, для отправки всех последующих команд используем полученный токен. Например:
     `socket.emit("getAssets",{token:token});` - команда-запрос на получение списка активов(от клиента к серверу)

1.    Для каждой существующей команды сервера у клиента должен быть реализован метод-обработчик. Например, для получения команды сервера "установить токен":
```
#!javascript

socket.on("setToken", function(data) {
        testCore.setToken(data.info.token);//записываем токен в локальное хранилище клиента
    });
```


Для получения команды сервера "отправить список всех активов":

```
#!javascript

    socket.on("getAssets", function(data) {
        //здесь обработка полученных данных (списка активов) от сервера
    });
```
и т.д.



### Примеры использования команд ###

* ** Команда от клиента "сделать перевод, с актива _from_ на актив _to_". **
```
socket.emit("transfer", {info:{from:<id_asset 'from'>, to:<id_asset 'to'}>});
```
Сервер должен: 
1.    отправить подтверждение об успешном выполнении команды. 
1.    Прислать обновленные активов данные клиенту(или клиентам, если юзер сидит сразу с нескольких устройств под одним аккаунтом).

* **Запрос от сервера "подтвердите получение перевода от партнера на ваш актив"**
```
socket.emit("transfer_wait_accept", {info:{from:<id_asset 'from'>, to:<id_asset 'to'}>});
```
где _from_ - партнер(как актив), 

_to_ - пользователь(как актив).


* **Запрос от сервера "подтвердите перевод с вашего актива на актив партнера"**
```
socket.emit("transfer_wait_accept", {info:{from:<id_asset 'from'>, to:<id_asset 'to'}>});
```
, где from - актив пользователя, to - партнер(как актив).

* **Команда от клиента "запрос перевода подтвержден"**
```
socket.emit("transfer_accept", {info:{from:<id_asset 'from'>, to:<id_asset 'to', my_asset:<id_asset> }>});
```
, где _from_ - актив списания(самого пользователя или партнера, 

_to_ - актив получения(партнера или самого пользователя), 

_my_asset_ - актив, куда(или откуда) будут положены(или списаны) средства.

**данный запрос работает в обе стороны - независимо от того, кто инициирует сделку.**

2. Если первоначальный запрос(_transfer_) пришел от партнера, то пользователь подтверждает этот запрос, отправляя те же самые _from_ и _to_, которые были созданы партнером. А _my_asset_ - это тот конкретный актив пользователя, на который он примет входящий перевод.

2. Если первоначальный запрос(_transfer_) отправил сам пользователь своему партнеру("я хочу списать с тебя n-ую сумму денег"), то подтверждает перевод партнер. И в таком случае 

_from_ и _to_ - те, что были созданы самим пользователем, 

а _my_asset_ - это тот конкретный актив партнера, на который он примет входящий перевод.



### Примеры использования подтверждений ###

Клиент и сервер шлют в ответ на запросы подтверждение(об успешности или неуспешности операции):
Если успешно выполнено:
```
socket.emit("ack", {status:"ok", info:{action:"<название метода, который был вызван>Ack"}});
```
Если не успешно выполнено:
socket.emit("ack", {status:"error", info:{action:"<название метода, который был вызван>Ack", error:"<информация_об_ошибке>}});


подтверждения всегда обозначаются как **"ack" (от англ _acknowledgment_ - "подтверждение")**

* **пример(подтверждение от сервера):**
```
socket.emit("ack", {info:{action:"authPhoneAck", status:"ok"}})
```
сервер подтвердил(_ack_), что команда(_auth_phone_) выполнена, и выполнена успешно(_status:"ok"_)

* **пример(подтверждение от сервера):**
```
socket.emit("ack", {info:{action:"authPhoneAck", error:"Не верно заданный формат телефона"}, status:"error"});
```
Сервер подтвердил, что команда выполнена, выполнена с ошибкой, и так же присылает подробное описание самой ошибки (ошибка может присылаться в виде номера ошибки, по которому можно получить описание, используя сверочную таблицу ошибок).

* **пример(подтверждение от клиента):**
```
socket.emit("ack", {info:{action:"transfer_wait_accept",from:<id>, to:<id>}, status:"ok"}); 
```
Клиент подтвердил, что запрос подтверждения перевода from->to был получен клиентом. И сервер может спокойно удалить эту операцию из очереди, больше не беспокоясь о ней.

* **пример(подтверждение от клиента):**
```
socket.emit("ack", {info:{action:"transfer_wait_accept",from:<id>, to:<id>, error:"wrong_from_id"}, status:"error"});
```
Клиент подтвердил, что запрос подтверждения перевода from->to был получен клиентом, но при этом актив со статусом from_id ему не известен. И теперь сервер должен как-то обработать эту ситуацию.


### Примеры использования методов-обработчиков команд и подтверждений ###

(Эти методы получают _"входящие"_ сообщения от другой стороны)

1. Получение токена:
```
socket.on("setToken", function(data) {
        testCore.setToken(data.info.token);//записываем токен в локальное хранилище клиента
    });
```

1. Получение списка всех активов:
```
    socket.on("getAssets", function(data) {
        //здесь обработка полученных данных (списка активов) от сервера
    });
```

### Полный список доступных методов API ###

##### ТОЛЬКО для клиентов ####


**2. Авторизация пользователя по номеру телефона(1-й шаг авторизации)**

**Команда:**
```
socket.emit("authPhone",{phone:<phone>,requestId:<random int number>});
```
_phone_ {Number} - номер телефона (ТОЛЬКО цифры)

_requestId_ - случайное целое число больше нуля, используется для проверки, какой статус у отправленного на сервер запроса("ок" или "error"). Этот же параметр приходит в подтверждении(вместе со статусом запроса). Нужен для работы в офлайн-режиме(отправка запросов из "стека запросов" и определение, какие из запросов были отклонены сервером).

**Подтверждение:**
```
socket.on("ack", {status:"ok", info:{action:"authPhone" ,requestId:<random int number> } });
```

**Коды ошибок:**
```user_not_found``` - пользователь с указанным номером не найден.


**3. Авторизация пользователя по СМС(2-й шаг авторизации) и получение персональных данных**

**Команда:**
```
socket.emit("authSms",{phone:phone, code:code, requestId:<random int number>});
```
_phone_ {Number} - номер телефона (ТОЛЬКО цифры)

_code_ {Number} - пароль, пришедший по СМС (ТОЛЬКО цифры)

_requestId_ - случайное целое число больше нуля, используется для проверки, какой статус у отправленного на сервер запроса("ок" или "error"). Этот же параметр приходит в подтверждении(вместе со статусом запроса). Нужен для работы в офлайн-режиме(отправка запросов из "стека запросов" и определение, какие из запросов были отклонены сервером).

**Подтверждение:**
```
socket.on("ack", {status:"ok", info:{action:"authSms", requestId:<random int number>} });
```

**После вызова команды следует ожидать событие:**

```
socket.on("setToken", function(data) {
var token = data.info.token;
...
});
```

Содержимое data.info:

_token_ - токен авторизации, который нужно использовать для вызова всех последующих методов.

_name_ - имя юзера,

_address_ - адрес,

_business_ - сфера деятельности,

_position_ - занимаемая должность,

_requisites_ - реквизиты (платежные и др.),

_city_ - город,

_company_ - компания.

_goods_ - список продуктов, услуг и/или документов пользователя(см. полное описание формата в описаниии метода "Получение профиля пользователя")

_phone_ - телефон пользователя.


**Коды ошибок:**
```user_not_found``` - пользователь с указанным номером не найден.


**4. Получение списка всех активов (активы и партнеры выводятся одним списком)**

**Команда:**
```
socket.emit("getAssets",{token:token, requestId:<random int number>  });
```
_token_ {String} - токен авторизации (40 символов, sha1-хэш)

_requestId_ - случайное целое число больше нуля, используется для проверки, какой статус у отправленного на сервер запроса("ок" или "error"). Этот же параметр приходит в подтверждении(вместе со статусом запроса). Нужен для работы в офлайн-режиме(отправка запросов из "стека запросов" и определение, какие из запросов были отклонены сервером).

**Подтверждение:**
```
socket.on("ack", {status:"ok", info:{action:"getAssetsAck", ,requestId:<random int number>} });
```

**После вызова команды следует ожидать событие:**
```
socket.on("getAssets", function(data) {
...
});
```
_data_ - это массив перечисляемых объектов(для iOS - Dictonary), каждый элемент которого содержит свойства:

_id_ - id актива,

_user_id_ (может отсутствовать) - id текущего пользователя,

_name_ - название актива,

_saldo_ - текущее сальдо для данного актива,

_unconfirmed_incoming_deals_ - количество неподтвержденных _входящих_ сделок по данному активу (ТОЛЬКО когда актив является партнером!),

_unconfirmed_outgoing_deals_ - количество неподтвержденных _исходящих_ сделок по данному активу (ТОЛЬКО когда актив является партнером!),

_type_ - тип актива(актив, партнер, категория расходов),

_is_cost_ - является категорией расходов(значение 1) или нет (значение 0),

_partner_id - user_id партнера, с которым связан актив(тип="партнер") данного юзера,

_partner_phone_ - номер телефона партнера, с которым связан данный актив(ТОЛЬКО когда актив является партнером!)

_was_declined_ - индикатор отклоненной сделки. Имеет параметр 1, если исходящее предложение сделки было отклонено, либо 0, если отклоненных сделок не было.

_last_updated_ - время последнего изменения актива (или партнера, или категории расхода), в формате [ISO 8601](https://ru.wikipedia.org/wiki/ISO_8601)

**Коды ошибок:**
*любые ошибки (их описание) это ошибки, генерируемые базой данных mysql (не нужно выводить их пользователю напрямую, достаточно просто написать что-то вроде "ошибка подключения, попробуйте подключиться через минуту")


**5. Получение истории операций актива(применимо так же к партнеру и к категории расходов)**

**Команда:**
```
socket.emit("getAssetHistory",{token:_token, assetId:_asset_id, offset:<Integer>, requestId:<random int number>});
```
_token_ {String} - токен авторизации (40 символов, sha1-хэш)

_assetId_ {Number} - id (номер) актива или партнера или категории расходов

_offset_ {Number} - смещение выборки истории, в записях. По умолчанию равно нулю. При значении 0 - будут показаны последние 25 записей. При значении 10 - последние записи, с 10-ой по 35-ую(с конца).

_requestId_ - случайное целое число больше нуля, используется для проверки, какой статус у отправленного на сервер запроса("ок" или "error"). Этот же параметр приходит в подтверждении(вместе со статусом запроса). Нужен для работы в офлайн-режиме(отправка запросов из "стека запросов" и определение, какие из запросов были отклонены сервером).
**Подтверждение:**
```
socket.on("ack", {status:"ok", info:{action:"getAssetHistory",requestId:<random int number>} });
```

**После вызова команды следует ожидать событие:**
```
socket.on("getAssetHistory", function(data) {
...
});
```
_data.history_ - это массив перечисляемых объектов(для iOS - Dictonary), каждый элемент которого содержит свойства:

_id_ - id действия. Используется для подтверждения или отклонения транзакций и установок нового сальдо.

_asset_id_ - id актива, партнера или категории расхода, по которому запрошена история (в будущем возможно будет удален. если нигде не используется),

_action_type_ - тип события. 

**Существуют следующие типы событий:**

* **SEND_PAYMENT** - с этого актива была списана сумма. Этот тип события может быть только у актива (не у партнера).

* **GET_PAYMENT** - на этот актив была зачислена сумма. Этот тип события может быть только у актива (не у партнера).

* **SET_SALDO** - этому активу было установлено новое сальдо. Этот тип события может быть только у актива (не у партнера).

* **SEND_INCOMING_PAYMENT_REQUEST** - на этот актив-партнер был отправлен запрос на **зачисление средств** (ожидает подтверждения со стороны получателя). Этот тип события может быть только у юзера-отправителя запроса.

* **SEND_OUTGOING_PAYMENT_REQUEST** - на этот актив-партнер был отправлен запрос на **получение средств** (ожидает подтверждения со стороны отправителя). Этот тип события может быть только у юзера-отправителя запроса.

* **GET_OUTGOING_PAYMENT_REQUEST** - на этот актив-партнер был получен запрос на перевод средств в пользу **получателя** запроса (от данного юзера ожидается подтверждение или отклонение перевода). Этот тип события может быть только у юзера-получателя запроса.

* **GET_INCOMING_PAYMENT_REQUEST** - на этот актив-партнер был получен запрос на перевод средств в пользу **отправителя** запроса. Этот тип события может быть только у юзера-получателя запроса.

* **SEND_SET_SALDO_REQUEST** - С этого актива-партнера был отправлен запрос на установку нового сальдо между партнерами. Этот тип события может быть только у юзера-отправителя запроса.

* **GET_SET_SALDO_REQUEST** - На этот актив-партнер был получен запрос на установку нового сальдо между партнерами. Этот тип события может быть только у юзера-получателя запроса.

_asset_type_ - тип актива ("asset" - актив, "partner" - партнер). (возможно будет удалено в будущем, если нигде не используется)

from_id - id актива или партнера, от которого поступило данное действие(может являться в том числе id актива/партнера, чья история была получена в данный момент).

to_id - id актива или партнера, на который поступило данное действие(может являться в том числе id актива/партнера, чья история была получена в данный момент).

_payment_sum_ - сумма перевода или нового предложенного сальдо.

_status_ - текущее состояние данного действия. Может изменяться для активов-партнеров (при подтверждении или отклонении операции).

**Существуют следующие типы состояний:**

* OK - действие с активом (списание или зачисление) успешно завершено. Состояние может быть только у актива.
* CANCEL - действие с активом (списание или зачиисление) успешно отклонено. Состояние может быть только у актива.
* PENDING - актив-партнер ожидает подтверждения или отклонения операции(перевод с, перевода на, установка нового сальдо). Состояние может быть только у актива-партнера.
* ACCEPT - актив-партнер успешно получил перевод (входящий или исходящий) или новое сальдо подтверждено(входящее или сходящее). Состояние может быть только у актива-партнера.
* DECLINE - перевод или установка нового сальдо отклонены(входящие или исходящие). Состояние может быть только у актива-партнера.

_hash_ - хэш данного действия. Используется для подтверждения или отклонения входящих переводов или предложений нового сальдо.

_comment_ - комментарий к данному действию.

_last_updated_ - время, когда было совершено данное действие с данным активом.

**Коды ошибок:**
*любые ошибки (их описание) это ошибки, генерируемые базой данных mysql (не нужно выводить их пользователю напрямую, достаточно просто написать что-то вроде "ошибка подключения, попробуйте подключиться через минуту")


**6. Добавление нового актива (asset) или партнера(partner) или категории расхода(cost)**

**Команда:**
```
//для нового актива
var params = {
    token:<token>,
    name: "<Название актива>",
    type: "asset",
    saldo: 0,
    requestId:<random int number>
};

//для нового партнера
var params = {
    token:<token>,
    name: "<Название партнера>",//можно пока не указывать, т.к. он совпадет с телефоном партнера
    type: "partner",
    saldo: 0,
    partnerPhone: <номер телефона партнера в международном формате, без "+" в начале>,
    myPhone:<телефон самого юзера>//возможно в будущем этот параметр будет удален
   ,requestId:<random int number>
};

//для новой категории расходов
var params = {
    token:<token>,
    name: "<Название категории расхода>",
    type: "asset",
    isCost: 1,
    saldo: 0
    ,requestId:<random int number>
};

socket.emit("addAsset",params);
```
_token_ {String} - токен авторизации (40 символов, sha1-хэш),

_name_ {String} - название нового актива,

_type_ {String} - тип актива "asset" (**Актив**) или "partner" (**Партнер**)

_isCost_ {Number} - если 0 или отсутствует, то просто актив или партнер, а если 1 - то записывается как "категория расходов",

_saldo_ {Number} - начальное сальдо актива,

_partnerPhone_ {Number} - <номер телефона партнера в международном формате, без "+" в начале>,

_myPhone_ {Number} -  <телефон самого юзера>//возможно в будущем этот параметр будет удален.

_requestId_ - случайное целое число больше нуля, используется для проверки, какой статус у отправленного на сервер запроса("ок" или "error"). Этот же параметр приходит в подтверждении(вместе со статусом запроса). Нужен для работы в офлайн-режиме(отправка запросов из "стека запросов" и определение, какие из запросов были отклонены сервером).

**Подтверждение:**
```
socket.on("ack", {status:"ok", info:{action:"addAssetAck",requestId:<random int number>} });
```

**После вызова команды следует ожидать событие:**

```
sock.on("addAsset", function (data) {
....
});
```
_data_ содержит объект вида ```{insertId:<Number>}```

_insertId_ - id только что добавленного актива или партнера или категории расходов. Используется для последующей загрузки изображения для актива или категории расхода или партнера(если партнер не установил сам свое изображение).

**Коды ошибок:**

Никаких специфических.


**7. Переименовывание актива**

**Команда:**
```
var params = { 
token:<token>,
newName: <String>,
assetId: <Number>,
requestId:<random int number>
};
socket.emit("renameAsset", params);
```
_token_ {String} - токен авторизации (40 символов, sha1-хэш)

_newName_ {String} - Новое название актива

_assetId_ {Number} - id актива, который переименовываем

_requestId_ - случайное целое число больше нуля, используется для проверки, какой статус у отправленного на сервер запроса("ок" или "error"). Этот же параметр приходит в подтверждении(вместе со статусом запроса). Нужен для работы в офлайн-режиме(отправка запросов из "стека запросов" и определение, какие из запросов были отклонены сервером).
**Подтверждение:**
```
socket.on("ack", {status:"ok", info:{action:"renameAssetAck",requestId:<random int number>} });
```

**После вызова команды следует ожидать событие:**

Никакого. Только подтверждение.

**Коды ошибок:**

_it_is_temporary_asset_ - "это временный актив" (его нельзя переименовывать).

_asset_id_not_found_ - не найден актив с указанным id.

**8. Удаление актива**

**Команда:**
```
var params = { 
token:<token>,
assetId: <Number>,
requestId:<random int number>
};
socket.emit("deleteAsset", params);
```
_token_ {String} - токен авторизации (40 символов, sha1-хэш)

_assetId_ {Number} - id актива, который удаляем

_requestId_ - случайное целое число больше нуля, используется для проверки, какой статус у отправленного на сервер запроса("ок" или "error"). Этот же параметр приходит в подтверждении(вместе со статусом запроса). Нужен для работы в офлайн-режиме(отправка запросов из "стека запросов" и определение, какие из запросов были отклонены сервером).
**Подтверждение:**
```
socket.on("ack", {status:"ok", info:{action:"deleteAssetAck",requestId:<random int number>} });
```

**После вызова команды следует ожидать событие:**

Никакого. Только подтверждение.

**Коды ошибок:**

_wrong_asset_id_ - не верно указан id актива.



**9. Переводы**

**Команда:**
```

//вариант для переброса средств с актива на актив
var params = {
    token: <token>,
    from: <asset_id_1>,
    to: <asset_id_2>,
    amount: 1,
    outgoingFromAsset:<Number>, //сумма списания с актива списания
    comment1:<String>,
    comment2:<String>,
    requestId:<random int number>
};


//вариант для отправки запроса на перевод средств со своего актива на актив партнера
var params = {
    token: <token>,
    from: <asset_id>,//Актив типа "актив"
    to: <asset_partner_id>,//Актив типа "партнер"
    amount: <Number>,//сумма зачисления на актив-партнер
    outgoingFromAsset: <Number>, //сумма списания с актива типа "актив"
    myPhone: myPhone,
    comment1:<String>,
    comment2:<String>,
    requestId:<random int number>
};

socket.emit("transfer", params);
```
_token_ {String} - токен авторизации (40 символов, sha1-хэш)

_from_ {Number} - id актива, откуда сделан перевод (может быть активом любого типа)

_to_ {Number} - id актива, откуда сделан перевод (может быть активом любого типа)

_amount_ {Number} - сумма зачисления на актив-получатель

_outgoingFromAsset_ {Number} - сумма, вычитаемая с баланса актива списания

_myPhone_ {Number} - телефон самого юзера. (возможно в будущем этот параметр будет удален)

_comment1_ {String} - комментарий для актива, с которого делается перевод. Используется как для переводов актив->актив, так и для актив->партнер и партнер->актив.

_comment2_ {String} - комментарий для актива, на который делается перевод. Используется как для переводов актив->актив, так и для актив->партнер и партнер->актив.

_requestId_ - случайное целое число больше нуля, используется для проверки, какой статус у отправленного на сервер запроса("ок" или "error"). Этот же параметр приходит в подтверждении(вместе со статусом запроса). Нужен для работы в офлайн-режиме(отправка запросов из "стека запросов" и определение, какие из запросов были отклонены сервером).

**Подтверждение:**
```
socket.on("ack", {status:"ok", info:{action:"transferAck",requestId:<random int number>} });
```

**После вызова команды следует ожидать событие:**

Никакого. Только подтверждение.

**Коды ошибок:**

_could_not_transfer_to_self_ - возникает при попытке сделать перевод с "актива 1" на "актив 1" (т.е. при ситуации, когда to=from)


**10. Отклонение перевода**

**Команда:**
```
var params = {
    token:<token>,
    assetId: <Number>,
    actionId: <Number>,
    actionHash: <String>,
    requestId:<random int number>
};

socket.emit("declineTransfer", params);
```
_token_ {String} - токен авторизации (40 символов, sha1-хэш)

_assetId_ {Number} - id актива, в котором отклоняем перевод (возможно будет удалено в будущем)

_actionId_ {Number} - id действия(перевода), которое отклоняем

_actionHash_ {String} - хэш действия, которое отменяем.

_requestId_ - случайное целое число больше нуля, используется для проверки, какой статус у отправленного на сервер запроса("ок" или "error"). Этот же параметр приходит в подтверждении(вместе со статусом запроса). Нужен для работы в офлайн-режиме(отправка запросов из "стека запросов" и определение, какие из запросов были отклонены сервером).

**Подтверждение:**
```
socket.on("ack", {status:"ok", info:{action:"declineTransferAck", error:<String>,requestId:<random int number>} });
```

**После вызова команды следует ожидать событие:**

(Возможно событие обновления списка активов, добавление бейджа нового события)

**Коды ошибок:**

_processing_erly_actions_before_ - Необходимо сперва обработать более ранние действия (входящие запросы)

_use_special_methods_for_temporary_asset_ - "Используйте специальные методы для работы с 'временным активом'". Возникает при попытке сделать перевод "актив->актив" из "временного актива" на обычный, с помощью метода _'transfer'_. Вместо этого надо использовать специальный метод _transferFromTemporaryAsset2Asset_.


**11. Подтверждение перевода**

**Команда:**
```
var params = {
    token:<token>,
    assetId: <Number>,
    actionId: <Number>,
    transferAssetId: <Number>,
    actionHash: <String>
    ,requestId:<random int number>
};


socket.emit("acceptTransfer", params);
```
_token_ {String} - токен авторизации (40 символов, sha1-хэш)

_assetId_ {Number} - id актива, в котором подтверждаем перевод

_actionId_ {Number} - id действия(перевода), которое подтверждаем (возможно будет удалено в будущем)

_transferAssetId_ {Number} - id актива, куда поместим входящий перевод(при переводе актив->партнер) или списываем исходящий перевод(при переводе партнер->актив)

_actionHash_ {String} - хэш действия, которое подтверждаем.

_requestId_ - случайное целое число больше нуля, используется для проверки, какой статус у отправленного на сервер запроса("ок" или "error"). Этот же параметр приходит в подтверждении(вместе со статусом запроса). Нужен для работы в офлайн-режиме(отправка запросов из "стека запросов" и определение, какие из запросов были отклонены сервером).


**Подтверждение:**
```
socket.on("ack", {status:"ok", info:{action:"acceptTransferAck", error:<String>,requestId:<random int number>} });
```

**После вызова команды следует ожидать событие:**

(Возможно событие обновления списка активов, добавление бейджа нового события)

**Коды ошибок:**

_processing_erly_actions_before_ - Необходимо сперва обработать более ранние действия (входящие запросы)


**12. Обновление профиля пользователя**

**Команда:**
```
var params = {
    token:<token>,
    name:<String>,
    address:<String>,
    business:<String>,
    position:<String>,
    requisites:<String>,
    requestId:<random int number>
};


socket.emit("setProfile", params);
```

_token_ {String} - токен авторизации (40 символов, sha1-хэш),

_name_ {String} - Имя пользователя в профиле,

_address_ {String} - юр. адрес,

_business_ {String} - вид деятельности, отрасль бизнеса (1 вариант из предлагаемого списка),

_position_ {String} - занимаемая должность,
 
_requisites_ {String} - реквизиты (ИП, ОГРН, р/о и пр. в виде 1-й большой строки).

_requestId_ - случайное целое число больше нуля, используется для проверки, какой статус у отправленного на сервер запроса("ок" или "error"). Этот же параметр приходит в подтверждении(вместе со статусом запроса). Нужен для работы в офлайн-режиме(отправка запросов из "стека запросов" и определение, какие из запросов были отклонены сервером).


**Подтверждение:**
```
socket.on("ack", {status:"ok", info:{action:"setProfileAck",requestId:<random int number>} });
```

**После вызова команды следует ожидать событие:**

Никакого. Можно обновить профиль

**Коды ошибок:**

Никаких специфических.



**13. Получение профиля пользователя**

**Команда:**
```
var params = {
    token:<token>,
    userPhone: <Number>,
    requestId:<random int number>
};


socket.emit("getProfile", params);
```
_token_ {String} - токен авторизации (40 символов, sha1-хэш),

_userPhone_ {Number} - номер телефона пользователя, профиль которого нужно получить.

_requestId_ - случайное целое число больше нуля, используется для проверки, какой статус у отправленного на сервер запроса("ок" или "error"). Этот же параметр приходит в подтверждении(вместе со статусом запроса). Нужен для работы в офлайн-режиме(отправка запросов из "стека запросов" и определение, какие из запросов были отклонены сервером).

**После вызова команды следует ожидать событие:**

```
socket.on("getProfile", function(data) {
var token = data.info.token;

});
```

_data_ - это массив перечисляемых объектов(для iOS - Dictonary), каждый элемент которого содержит свойства:


_token_ - токен авторизации, который нужно использовать для вызова всех последующих методов.

_name_ {String} - Имя пользователя в профиле,

_address_ {String} - юр. адрес,

_business_ {String} - вид деятельности, отрасль бизнеса (1 вариант из предлагаемого списка),

_position_ {String} - занимаемая должность,
 
_requisites_ {String} - реквизиты (ИП, ОГРН, р/о и пр. в виде 1-й большой строки).

_goods_ {Array/String} - товары или услуги данного пользователя. **(не реализовано в настоящее время)**

```
goods = [
    {id:<Number>,
        name:<String>,
        description:<String>,
        images: [
            {title:<String>, url:<String>},
            {title:<String>, url:<String>},
            {title:<String>, url:<String>},
            ...
        ],
    site:<String>
    },
    ...
];
```
Описание содержимого goods:

_id_ - уникальный id товара или услуги, 

_name_ - название товара или услуги,

_description_ - описание товара или услуги,
images - массив со списком из картинок товара или услуги и заголовка к ним,
site - ссылка на сайт по данному товару или услуге.


**Подтверждение:**
```
socket.on("ack", {status:"ok", info:{action:"getProfileAck",requestId:<random int number>} });
```

**После вызова команды следует ожидать событие:**

```
socket.on("getProfile", function(data) {
...
});
```

**Коды ошибок:**

_user_not_found_ - пользователь не найден.


**14. Установка/обновление push-токена пользователя**

**Команда:**
```
var params = {
    token:<token>,
    pushToken: <pushToken>
    ,requestId:<random int number>
};


socket.emit("setPushToken", params);
```

_token_ {String} - токен авторизации (40 символов, sha1-хэш),

_pushToken_ {String} - токен для отправки ios/android-клиенту push-уведомлений (клиент берет его из APNs и присылает сюда)

_requestId_ - случайное целое число больше нуля, используется для проверки, какой статус у отправленного на сервер запроса("ок" или "error"). Этот же параметр приходит в подтверждении(вместе со статусом запроса). Нужен для работы в офлайн-режиме(отправка запросов из "стека запросов" и определение, какие из запросов были отклонены сервером).

**Подтверждение:**
```
socket.on("ack", {status:"ok", info:{action:"setPushTokenAck",requestId:<random int number>} });
```

**После вызова команды следует ожидать событие:**

Никакого. 

**Коды ошибок:**

Никаких специфических.


**15. Установка нового сальдо для актива или партнера пользователя**

**Команда:**
```
var params = {
    token:<token>,
    assetId: <Number>,
    newSaldo: <Number>
    ,requestId:<random int number>
};


socket.emit("setSaldo", params);
```

_token_ {String} - токен авторизации (40 символов, sha1-хэш),

_assetId_ {Number} - id актива или партнера, которому устанавливаем новое сальдо. В случае установки сальдо партнеру, нужно получить подтверждение от партнера.

_newSaldo_ {Number} - новое сальдо для актива или партнера.

_requestId_ - случайное целое число больше нуля, используется для проверки, какой статус у отправленного на сервер запроса("ок" или "error"). Этот же параметр приходит в подтверждении(вместе со статусом запроса). Нужен для работы в офлайн-режиме(отправка запросов из "стека запросов" и определение, какие из запросов были отклонены сервером).

**Подтверждение:**
```
socket.on("ack", {status:"ok", info:{action:"setSaldoAck",requestId:<random int number>} });
```

**После вызова команды следует ожидать событие:**

Никакого. 

**Коды ошибок:**

Никаких специфических.


**16. Подтверждение нового сальдо для партнера пользователя**

**Команда:**
```
var params = {
    token:<token>,
    actionHash: <String>
    ,requestId:<random int number>
};


socket.emit("acceptNewSaldo", params);
```

_token_ {String} - токен авторизации (40 символов, sha1-хэш),

_actionHash_ {String} - хэш действия, которое подтверждаем.

_requestId_ - случайное целое число больше нуля, используется для проверки, какой статус у отправленного на сервер запроса("ок" или "error"). Этот же параметр приходит в подтверждении(вместе со статусом запроса). Нужен для работы в офлайн-режиме(отправка запросов из "стека запросов" и определение, какие из запросов были отклонены сервером).


**Подтверждение:**
```
socket.on("ack", {status:"ok", info:{action:"acceptNewSaldoAck",requestId:<random int number>} });
```

**После вызова команды следует ожидать событие:**

Никакого. 

**Коды ошибок:**

Никаких специфических.



**17. Отклонение нового сальдо для партнера пользователя**

**Команда:**
```
var params = {
    token:<token>,
    actionHash: <String>
    ,requestId:<random int number>
};


socket.emit("declineNewSaldo", params);
```

_token_ {String} - токен авторизации (40 символов, sha1-хэш),

_actionHash_ {String} - хэш действия, которое отклоняем.

_requestId_ - случайное целое число больше нуля, используется для проверки, какой статус у отправленного на сервер запроса("ок" или "error"). Этот же параметр приходит в подтверждении(вместе со статусом запроса). Нужен для работы в офлайн-режиме(отправка запросов из "стека запросов" и определение, какие из запросов были отклонены сервером).


**Подтверждение:**
```
socket.on("ack", {status:"ok", info:{action:"declineNewSaldoAck",requestId:<random int number>} });
```

**После вызова команды следует ожидать событие:**

Никакого. 

**Коды ошибок:**

Никаких специфических.


**18. "Я онлайн"**

**Описание:**

Должна вызываться всякий раз, когда у пользователя открыто приложение (запущено и развернуто).

Данный метод позволяет партнерам данного пользователя отправлять ему моментальные ws-сообщения (вместо push-сообщений, которые отправляются когда приложение пользователя закрыто или свернуто).

Нужно вызывать после авторизации (как только стал доступен токен юзера), а так же каждый раз при разворачивании приложения (сразу после установки ws-соединения).


**Команда:**
```
var params = {
    token:<token>
    ,requestId:<random int number>
};


socket.emit("ionline", params);
```

_token_ {String} - токен авторизации (40 символов, sha1-хэш)

_requestId_ - случайное целое число больше нуля, используется для проверки, какой статус у отправленного на сервер запроса("ок" или "error"). Этот же параметр приходит в подтверждении(вместе со статусом запроса). Нужен для работы в офлайн-режиме(отправка запросов из "стека запросов" и определение, какие из запросов были отклонены сервером).
**Подтверждение:**
```
socket.on("ack", {status:"ok", info:{action:"ionlineAck",requestId:<random int number>} });
```

**После вызова команды следует ожидать событие:**

Никакого. 

**Коды ошибок:**

Никаких специфических.





**19. Обработка входящих ws-сообщений**

**Описание:**

Каждый ws-клиент должен "слушать"(listen) событие **ws.incoming.messages** и обрабатывать приходящие в него "входящие сообщения".
Сообщения бывают 2 видов: 

* транзакция
* предложение нового сальдо

(В будущем возможен 3-ий вид, это "сообщение чата".)


**Шаблон кода обработчика:**

```
socket.on("ws.incoming.messages", function(data) {
    //console.log(data.info);
});
```

_data.info_ - это массив перечисляемых объектов(для iOS - Dictonary), который содержит:

_alert_ - Сообщение о виде входящего ws-сообщения (сейчас это сообщения на кириллице, аналогичные тем, которые отправляются в push-сообщениях. В будущем это будут константы на латинице).

_assetId_ - id актива-партнера, который прислал предложение новой сделки или установки нового сальдо.

**После вызова команды следует ожидать событие:**

Никакого. 

**Коды ошибок:**

Никаких специфических.



**20. Перевод с "временного актива" на актив**

**Команда:**
```
var params = {
            token: <token>,
            from: <Number>,
            to: <Number>,
            actionHash: <String>
            ,requestId:<random int number>
};

socket.emit("transferFromTemporaryAsset2Asset", params);
```
_token_ {String} - токен авторизации (40 символов, sha1-хэш)

_actionHash_ {String} - хэш из истории действий **во "временном активе"** ,

_from_ {Number} - id "временного актива"(в будущем данный параметр может быть убран),

_to_ {Number} - id актива, откуда сделан перевод (может быть ТОЛЬКО активом)

_requestId_ - случайное целое число больше нуля, используется для проверки, какой статус у отправленного на сервер запроса("ок" или "error"). Этот же параметр приходит в подтверждении(вместе со статусом запроса). Нужен для работы в офлайн-режиме(отправка запросов из "стека запросов" и определение, какие из запросов были отклонены сервером).


**Подтверждение:**
```
socket.on("ack", {status:"ok", info:{action:"transferFromTemporaryAsset2AssetAck",requestId:<random int number>} });
```

**После вызова команды следует ожидать событие:**

Никакого. Только подтверждение.

**Коды ошибок:**

_action_not_found_ - не правильно задан actionHash.


**21. Удаление записи из "временного актива"**

**Команда:**
```
var params = {
            token: <token>,
            from: <Number>,
            to: <Number>,
            actionHash: <String>
            ,requestId:<random int number>
};

socket.emit("deleteFromTemporaryAsset", params);
```
_token_ {String} - токен авторизации (40 символов, sha1-хэш)

_actionHash_ {String} - хэш из истории действий **во "временном активе"** ,

_requestId_ - случайное целое число больше нуля, используется для проверки, какой статус у отправленного на сервер запроса("ок" или "error"). Этот же параметр приходит в подтверждении(вместе со статусом запроса). Нужен для работы в офлайн-режиме(отправка запросов из "стека запросов" и определение, какие из запросов были отклонены сервером).

**Подтверждение:**
```
socket.on("ack", {status:"ok", info:{action:"deleteFromTemporaryAssetAck",requestId:<random int number>} });
```

**После вызова команды следует ожидать событие:**

Никакого. Только подтверждение.

**Коды ошибок:**

_action_not_found_ - не правильно задан actionHash.





**22. Редактирование товара или услуги в профилю пользователя** 

**Команда:**
```

var params = {
            token:<token>,
            requestId:<random int number>,
            goods: [
                   {
                    name: 'имя медиа-ресурса(услуги или др.)',
                    images: 
                          [
                            {
                               title:"Название/описание картинки",
                                url:"<путь_до_файла_картинки>"
                            },
                            {
                               title:"Название/описание картинки 2",
                                url:"<путь_до_файла_картинки>"
                            },
                           ...
                    ],
                    description: "описание медиа-ресурса",
                    site:"<ссылка_на_сайт>"
                },

                   {
                    name: 'имя другого медиа-ресурса',
                    images: 
                          [
                            {
                               title:"Название/описание картинки",
                                url:"<путь_до_файла_картинки>"
                            },
                            {
                               title:"Название/описание картинки 2",
                                url:"<путь_до_файла_картинки>"
                            },
                           ...
                    ],
                    description: "описание другого медиа-ресурса",
                    site:"<ссылка_на_сайт>"
                },
                ...
            ]
        };


socket.emit("updateGoods", params);
```
_token_ {String} - токен авторизации (40 символов, sha1-хэш),

_name_ - название нового товара или услуги,

_description_ - описание нового товара или услуги,

_images_ - массив со списком из картинок нового товара или услуги и заголовков к ним,

_site_ - ссылка на сайт к новому данному товару или услуге.

_requestId_ - случайное целое число больше нуля, используется для проверки, какой статус у отправленного на сервер запроса("ок" или "error"). Этот же параметр приходит в подтверждении(вместе со статусом запроса). Нужен для работы в офлайн-режиме(отправка запросов из "стека запросов" и определение, какие из запросов были отклонены сервером).

**Подтверждение:**
```
socket.on("ack", {status:"ok", info:{action:"updateGoodsAck",requestId:<random int number>} });
```

**После вызова команды следует ожидать событие:**

Никакого.

**Коды ошибок:**

Никаких специфических.



**23. Удаление записей из истории транзакций** 


**Описание:**

Удалять можно любые записи из истории транзакций, кроме не обработанных (имеющих status='PENDING').

Удалять можно только свои собственные записи из истории транзакций(в ином случае будет получена ошибка. подробнее см. ниже).



**Команда:**
```
var params = {
    token:<String>,
    actionsIds:<Numbers array>
    , requestId:<random int number>
};

socket.emit("deleteTransactionsHistory", params);
```

_token_ {String} - токен авторизации (40 символов, sha1-хэш),

_actionsIds_ - массив из id записей истории транзакций (т.е. тех, которые получаем при вызове метода _getAssetHistory_).

_requestId_ - случайное целое число больше нуля, используется для проверки, какой статус у отправленного на сервер запроса("ок" или "error"). Этот же параметр приходит в подтверждении(вместе со статусом запроса). Нужен для работы в офлайн-режиме(отправка запросов из "стека запросов" и определение, какие из запросов были отклонены сервером).


**Подтверждение:**
```
socket.on("ack", {status:"ok", info:{action:"deleteTransactionsHistoryAck",requestId:<random int number>} });
```

**После вызова команды следует ожидать событие:**

Никакого.

**Коды ошибок:**

_expect_not_null_actionsIds_parameter_ - не было передано ни одного id записи из истории транзакций в параметре _actionsIds_,

_actionsIds_must_belong_current_user_ - в массиве _actionsIds_ нет ни одного id записи из истории транзакций, принадлежащих данному юзеру,

_actionsIds_not_found_ - не было найдено, что нужно удалять(скорее всего данная ошибка никогда не будет передана клиенту).



**24. Удаление аккаунта.** 


**Описание:**

Удаляет аккаунт юзера.


**Команда:**
```
var params = {
    token:<String>,
    requestId:<random int number>
};

socket.emit("deleteAccount", params);
```

_token_ {String} - токен авторизации (40 символов, sha1-хэш),

_requestId_ - случайное целое число больше нуля, используется для проверки, какой статус у отправленного на сервер запроса("ок" или "error"). Этот же параметр приходит в подтверждении(вместе со статусом запроса). Нужен для работы в офлайн-режиме(отправка запросов из "стека запросов" и определение, какие из запросов были отклонены сервером).

**Подтверждение:**
```
socket.on("ack", {status:"ok", info:{action:"deleteAccountAck",requestId:<random int number>} });
```

**После вызова команды следует ожидать событие:**

Никакого.

**Коды ошибок:**

Никаких специфических.